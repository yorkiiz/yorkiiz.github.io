### 二.jvm升华篇

#### 1.1如何确定一个对象是垃圾

#### 1.1.1可达性分析

​        对每个对象进行可达性分析

​       不可达对象需要进行两次标记才会回收，被标记并且进行一次筛选

​      筛选的条件是是有有必要执行finalize方法， 调用或者重写finalize，就不会回收

#### 1.1.2引用计数器









#### 1.2垃圾回收算法

##### 1.2.1.标记-清除算法 CMS

（1）耗时

（2）产生碎片比较多，遇到大对象时，无法找到足够的连续内存而不得不触发另一次垃圾收集动作（CMS）



##### 1.2.2.复制算法 serial，parnew，parallel scavenge

缺点：空间利用率降低

新生代通常复制算法，因为对象比较少



##### 1.2.3标记整理法 serial old ，parallel old

##### 1.2.4分代收集算法

-------------------------------------------------------

#### 1.3垃圾收集器

##### 1.3.1serial收集器

复制算法



##### 1.3.2parall new收集器

1）复制算法

2）并行收集

并行：在同一时间点上能同时运行多个线程，单cpu

并发：时间段



##### 1.3.3. parallel scavenge

1）复制算法

2）并行收集器

3）追求吞吐量



##### 1.3.4 serial old

1）标记-整理算法

2）单线程



##### 1.3.5 parallel old

1）标记-整理算法

2）并行收集器

3）追求吞吐量



##### 1.3.6 CMS收集器

Concurrent Mark Sweep

1）并发收集器

2）追求最短停顿时间

3）分为4步

4）标记-清除算法



##### 1.3.7 G1收集器

1）并发收集器

2）追求最短停顿时间

3）分为4步（初始标记，并发标记，重新标记，并发标记）

初始标记：

4）标记-整理



![image-20210807221909205](C:\Users\admin\AppData\Roaming\Typora\typora-user-images\image-20210807221909205.png)

|        | 标记-清除 | 复制算法                                                     | 标记整理                                                     | 分代收集器 |
| :----: | --------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------- |
| 新生代 |           | serial，parnew（单线程），**parallel scavenge**（并行，默认） | G1                                                           |            |
| 老年代 | CMS       |                                                              | **serial old**（单线程，吞吐），parallel old（并行，吞吐），G1 |            |

